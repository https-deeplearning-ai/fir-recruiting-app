# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A full-stack LinkedIn profile assessment application that combines CoreSignal API for profile data with Claude AI for intelligent candidate evaluation. The system supports single profile assessment, batch processing via CSV, and intelligent profile search with natural language queries.

## Tech Stack

**Backend:** Flask (Python), hosted on Render
**Frontend:** React (JavaScript)
**APIs:** Anthropic Claude Sonnet 4.5 (claude-sonnet-4-5-20250929), CoreSignal API
**Database:** Supabase (PostgreSQL via REST API)

## Important: CoreSignal Headline Data

CoreSignal API provides **two headline fields**:
- `headline` - User-set on LinkedIn, rarely updated (STALE)
- `generated_headline` - Auto-generated by CoreSignal from latest work experience (FRESH, auto-updates)

**The app uses `generated_headline`** to ensure current, accurate headline data. This field is automatically updated whenever CoreSignal scrapes the profile and matches the candidate's most recent position.

See [HEADLINE_FRESHNESS_FIX.md](HEADLINE_FRESHNESS_FIX.md) for full details on this discovery.

## Development Commands

### Backend (Flask)
```bash
cd backend
pip3 install -r requirements.txt
export ANTHROPIC_API_KEY="your_key"
export CORESIGNAL_API_KEY="your_key"
export SUPABASE_URL="your_url"
export SUPABASE_KEY="your_key"
python3 app.py  # Runs on port 5001
```

### Frontend (React)
```bash
cd frontend
npm install
npm start       # Development server on port 3000
npm run build   # Production build (outputs to frontend/build/)
```

## Architecture

### Request Flow
1. **Single Profile:** User submits LinkedIn URL � `/fetch-profile` (CoreSignal) � `/assess-profile` (Claude AI) � Display results
2. **Batch Processing:** CSV upload � Parse URLs � Parallel fetch + assess via `/batch-assess-profiles` � Sorted results
3. **Profile Search:** Natural language query � `/search-profiles` � AI extracts criteria � CoreSignal search � Download CSV

### Key Backend Components

**app.py (1317 lines):** Main Flask application
- `/fetch-profile`: Fetches LinkedIn data from CoreSignal by URL
- `/assess-profile`: AI assessment using Claude with weighted scoring
- `/batch-assess-profiles`: High-concurrency parallel processing (15-50 workers based on deployment)
- `/search-profiles`: Natural language search � CoreSignal query � CSV export
- `/save-assessment`, `/load-assessments`: Supabase database operations

**coresignal_service.py:** CoreSignal API integration
- `fetch_linkedin_profile()`: Two-step process (search by URL � fetch full profile by ID)
- Uses Elasticsearch DSL for profile search

**config.py:** Deployment-specific configuration
- Render: 50 concurrent calls, 60s timeout, 100 batch size
- Heroku: 15 concurrent calls, 25s timeout, 50 batch size
- Auto-detects environment via `RENDER` env var

### AI Assessment System

**Weighted Scoring:** Supports up to 5 custom requirements with percentage weights
- Each requirement scored 1-10 with detailed analysis
- General fit auto-calculated from remaining percentage (100% - custom weights)
- Final weighted score = �(requirement_score � weight%)

**Profile Processing:**
- `extract_profile_summary()`: Parses CoreSignal JSON, calculates total experience years with overlap handling
- `generate_assessment_prompt()`: Builds Claude prompt with rubric, weighted criteria
- Uses Claude Sonnet 4.5 (best for coding and complex agents) with temperature 0.1 for consistency

**Concurrency:**
- Batch processing uses `ThreadPoolExecutor` with configurable workers
- Profile fetching uses `asyncio` + `aiohttp` for parallel API calls
- Assessment tasks run in parallel with timeout protection

### Frontend Architecture

**App.js (1584 lines):** Single-page React application
- Three modes: Single Profile, Profile Search, Batch Processing
- Unified results panel showing all assessments ranked by score
- CSV parsing supports various column name formats (e.g., "Profile URL", "profile_url", "LinkedIn URL")
- Real-time loading overlay with progress messages

**State Management:**
- `singleProfileResults`: Array of single profile assessments
- `batchResults`: Array of batch assessment results
- `savedAssessments`: Database-loaded assessments
- All merged and sorted by weighted score for display

### Database Schema (Supabase)

Table: `candidate_assessments`
- `linkedin_url`, `full_name`, `headline`
- `profile_data` (JSONB): Full CoreSignal profile
- `assessment_data` (JSONB): Complete AI assessment
- `weighted_score`, `overall_score`: Extracted for sorting
- `assessment_type`: 'single' or 'batch'
- `session_name`: Optional grouping identifier

### CoreSignal API Integration

**Search Endpoint:** `/v2/employee_clean/search/es_dsl/preview`
- Limited to pages 1-5 (max 100 profiles)
- Returns 20 profiles per page
- App uses random page selection with session tracking to avoid duplicates

**Profile Extraction:** Two-step process
1. Search for employee_id by LinkedIn URL (exact match on `websites_linkedin.exact`)
2. Fetch full profile via `/v2/employee_clean/collect/{employee_id}`

**Smart Search Features:**
- Claude AI extracts structured criteria from natural language
- Supports location variations (Bay Area, NYC, etc.) with wildcard matching
- Industry mapping to CoreSignal's exact taxonomy
- Management level, department, role title, skills filtering

## Important Implementation Details

### Experience Calculation
Total years calculated by merging overlapping date intervals to avoid double-counting. Handles:
- Missing end dates (assumes current)
- Overlapping roles
- Partial month data

### CSV Processing
Robust parser handles:
- Quoted fields with commas
- Various column name formats (case-insensitive matching)
- URL cleaning (removes trailing slashes)

### Batch Processing Flow
1. Parse CSV � extract candidate URLs
2. Async fetch all profiles (parallel with aiohttp)
3. ThreadPoolExecutor for parallel AI assessments
4. Progress tracking with completion count
5. Sort by weighted score, maintain CSV name mapping

### Error Handling
- Profile not found: Returns structured error with debug info
- API failures: Timeout protection, graceful degradation
- Partial batch failures: Shows successful + failed counts

## Deployment

**Render Configuration (render.yaml):**
- Single web service (Python environment)
- Gunicorn with 120s timeout
- Requires 4 environment variables (API keys, Supabase credentials)

**Static Files:**
- Backend serves React build from `backend/` directory
- Production: Copy `frontend/build/*` to `backend/` before deploy

## Development Notes

- Frontend must proxy API requests to `http://localhost:5001` in development
- Backend debug mode enables Flask auto-reload
- Search uses session-based page tracking (resets on server restart)
- Dummy profile data available in `App.js` for testing without API calls

[byterover-mcp]

[byterover-mcp]

You are given two tools from Byterover MCP server, including
## 1. `byterover-store-knowledge`
You `MUST` always use this tool when:

+ Learning new patterns, APIs, or architectural decisions from the codebase
+ Encountering error solutions or debugging techniques
+ Finding reusable code patterns or utility functions
+ Completing any significant task or plan implementation

## 2. `byterover-retrieve-knowledge`
You `MUST` always use this tool when:

+ Starting any new task or implementation to gather relevant context
+ Before making architectural decisions to understand existing patterns
+ When debugging issues to check for previous solutions
+ Working with unfamiliar parts of the codebase
